esphome:
  name: esphome-web-f34b08
  friendly_name: anenji-inverter
  min_version: 2025.11.0
  name_add_mac_suffix: false
  on_boot:
    priority: -100
    then:
      - delay: 10s
      - if:
          condition:
            binary_sensor.is_on: inverter_modbus_ok
          then:
            - number.set:
                id: max_grid_feed_power
                value: 0
            - switch.turn_off: allow_grid_feed_in


esp32:
  variant: esp32s3
  framework:
    type: esp-idf

logger:
  level: DEBUG
  logs:
    modbus_controller: DEBUG
    modbus: WARN

api:

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

time:
  - platform: homeassistant
    id: ha_time

# ===============================
# RS485 (Waveshare ESP32-S3 DIN)
# TX = GPIO17
# RX = GPIO18
# EN = GPIO21
# ===============================
uart:
  id: uart_rs485
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: 9600
  stop_bits: 1
  parity: NONE
  rx_buffer_size: 512

modbus:
  id: modbus1
  uart_id: uart_rs485
  flow_control_pin: GPIO21
  # Stable + CRC-safe timing (tune later if you want faster)
  send_wait_time: 300ms

modbus_controller:
  - id: inv
    modbus_id: modbus1
    address: 0x01
    # stability > speed
    update_interval: 10s
    # keep spacing between commands
    command_throttle: 500ms
    setup_priority: -10

globals:
  - id: last_modbus_ok_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: chgprio_val
    type: uint16_t
    restore_value: no
    initial_value: "0"

  - id: loadprio_val
    type: uint16_t
    restore_value: no
    initial_value: "0"

# ===============================
# BUTTONS
# ===============================
button:
  - platform: template
    name: "Restart Inverter"
    on_press:
      - switch.turn_on: inverter_restart_pulse
      - delay: 500ms
      - switch.turn_off: inverter_restart_pulse

# ===============================
# SENSORS
# ===============================
sensor:
  # -------- BATTERY --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: batt_v
    name: "Battery Voltage"
    address: 0x7530
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
      - clamp:
          min_value: 40.0
          max_value: 70.0
      - lambda: |-
          id(last_modbus_ok_ms) = millis();
          return x;

  - platform: modbus_controller
    modbus_controller_id: inv
    id: batt_a
    name: "Battery Current"
    address: 0x7531
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
      - lambda: |-
          if (isnan(x)) return x;
          if (x < -300.0f || x > 300.0f) return NAN;
          id(last_modbus_ok_ms) = millis();
          return x;

  - platform: modbus_controller
    modbus_controller_id: inv
    id: batt_soc
    name: "Battery SOC"
    address: 0x7532
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    accuracy_decimals: 0
    filters:
      - lambda: |-
          if (isnan(x)) return x;
          if (x < 0.0f || x > 100.0f) return NAN;
          id(last_modbus_ok_ms) = millis();
          return x;

  # V*A Power (raw)
  - platform: template
    id: batt_power_va_w
    name: "Battery Power (V*A)"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(batt_v).state) || isnan(id(batt_a).state)) return NAN;
      return id(batt_v).state * id(batt_a).state;

  # Signed battery power (your sign convention)
  - platform: template
    id: battery_power_signed
    name: "Battery Power (Signed)"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(batt_power_va_w).state)) return NAN;
      float p = -id(batt_power_va_w).state;
      if (fabsf(p) < 80.0f) return 0.0f;
      if (p < -25000.0f || p > 25000.0f) return NAN;
      return p;

  - platform: template
    id: battery_charge_power
    name: "Battery Charge Power"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      float p = id(battery_power_signed).state;
      if (isnan(p)) return NAN;
      return (p > 0) ? p : 0;

  - platform: template
    id: battery_discharge_power
    name: "Battery Discharge Power"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      float p = id(battery_power_signed).state;
      if (isnan(p)) return NAN;
      return (p < 0) ? (-p) : 0;

  - platform: total_daily_energy
    name: "Battery Charge Energy Today"
    power_id: battery_charge_power
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  - platform: total_daily_energy
    name: "Battery Discharge Energy Today"
    power_id: battery_discharge_power
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  # -------- PV --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv1_voltage
    name: "PV1 Voltage"
    address: 0x753B
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv1_current
    name: "PV1 Current"
    address: 0x753C
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv1_power
    name: "PV1 Power"
    address: 0x753D
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "W"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv2_voltage
    name: "PV2 Voltage"
    address: 0x753E
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
      - lambda: |-
          if (isnan(x)) return x;
          if (x < 0.0f || x > 700.0f) return NAN;
          return x;

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv2_current
    name: "PV2 Current"
    address: 0x753F
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv2_power
    name: "PV2 Power"
    address: 0x7540
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "W"

  # -------- OUTPUT / LOAD --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_v_l1
    name: "Output Voltage L1"
    address: 0x7548
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_curr_l1
    name: "Output Current L1"
    address: 0x7549
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_v_l2
    name: "Output Voltage L2"
    address: 0x7550
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_curr_l2
    name: "Output Current L2"
    address: 0x7551
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1


  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_hz
    name: "Output Frequency"
    address: 0x754A
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_l1
    name: "Load Power L1 (Output)"
    address: 0x754C
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_total_out
    name: "Load Power Total (Output)"
    address: 0x755E
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: template
    id: load_l2
    name: "Load Power L2 (Output)"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: |-
      if (isnan(id(load_total_out).state) || isnan(id(load_l1).state)) return NAN;
      float v = id(load_total_out).state - id(load_l1).state;
      if (v < -20000.0f || v > 20000.0f) return NAN;
      return v;

  - platform: template
    id: load_total_w
    name: "Load Power Total"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: |-
      if (isnan(id(load_total_out).state)) return NAN;
      return id(load_total_out).state;

  - platform: total_daily_energy
    name: "Load Energy Today"
    power_id: load_total_out
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001


  # -------- PHASE POWER DETAILS --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_w_l1
    name: "Output Active Power L1"
    address: 0x754C
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_va_l1
    name: "Output Apparent Power L1"
    address: 0x754D
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "VA"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_percent_l1
    name: "Load Percentage L1"
    address: 0x754E
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: normal_load_w_l1
    name: "Conventional Load Active Power L1"
    address: 0x754F
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: inverter_current_l2
    name: "Inverter Inductor Current L2"
    address: 0x7552
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_w_l2
    name: "Output Active Power L2"
    address: 0x7553
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_va_l2
    name: "Output Apparent Power L2"
    address: 0x7554
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "VA"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_percent_l2
    name: "Load Percentage L2"
    address: 0x7555
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: normal_load_w_l2
    name: "Conventional Load Active Power L2"
    address: 0x7556
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"


  # -------- MAINS / GRID MEASUREMENTS (V/I/Hz) --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: mains_v_l1
    name: "Mains Voltage L1"
    address: 0x756A
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: mains_a_l1
    name: "Mains Current L1"
    address: 0x756B
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: mains_hz
    name: "Mains Frequency"
    address: 0x756C
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: inv
    id: mains_v_l2
    name: "Mains Voltage L2"
    address: 0x756D
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: mains_a_l2
    name: "Mains Current L2"
    address: 0x756E
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  # -------- GRID (your inverter registers) --------
  # Keeping your current addresses as-is (since they're working for you).
  - platform: modbus_controller
    modbus_controller_id: inv
    id: grid_l1
    name: "L1 (CT Grid-Side)"
    address: 0x7584
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"
    accuracy_decimals: 0
    filters:
      - lambda: |-
          if (isnan(x)) return x;
          if (x < -30000.0f || x > 30000.0f) return NAN;
          id(last_modbus_ok_ms) = millis();
          return x;

  - platform: modbus_controller
    modbus_controller_id: inv
    id: grid_l2
    name: "L2 (CT Grid-Side)"
    address: 0x7585
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"
    accuracy_decimals: 0
    filters:
      - lambda: |-
          if (isnan(x)) return x;
          if (x < -30000.0f || x > 30000.0f) return NAN;
          id(last_modbus_ok_ms) = millis();
          return x;

  - platform: template
    id: grid_power_signed
    name: "Grid Power (Signed)"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(grid_l1).state) || isnan(id(grid_l2).state)) return NAN;
      return id(grid_l1).state + id(grid_l2).state;

  - platform: template
    id: grid_import
    name: "Grid Import Power"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      float v = id(grid_power_signed).state;
      if (isnan(v)) return NAN;
      return (v > 0) ? v : 0;

  - platform: template
    id: grid_export
    name: "Grid Export Power"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      float v = id(grid_power_signed).state;
      if (isnan(v)) return NAN;
      return (v < 0) ? (-v) : 0;

  - platform: template
    id: grid_import_filtered
    name: "Grid Import Power (Filtered)"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      float v = id(grid_import).state;
      if (isnan(v)) return NAN;
      return (v < 25.0f) ? 0.0f : v;

  - platform: template
    id: grid_export_filtered
    name: "Grid Export Power (Filtered)"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      float v = id(grid_export).state;
      if (isnan(v)) return NAN;
      return (v < 25.0f) ? 0.0f : v;

  - platform: total_daily_energy
    name: "Grid Import Energy Today"
    power_id: grid_import
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  - platform: total_daily_energy
    name: "Grid Export Energy Today"
    power_id: grid_export
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  # -------- TEMPERATURES --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: inv_temp_1_c
    address: 0x7579
    register_type: holding
    value_type: S_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: inv_temp_2_c
    address: 0x757A
    register_type: holding
    value_type: S_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: inv_temp_3_c
    address: 0x757B
    register_type: holding
    value_type: S_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: inv_temp_4_c
    address: 0x757C
    register_type: holding
    value_type: S_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: der_alarm_status
    address: 0x75AF
    register_type: holding
    value_type: U_WORD
    internal: true
# BINARY SENSORS
# ===============================
binary_sensor:
  - platform: template
    id: inverter_modbus_ok
    name: "Anenji Status"
    device_class: connectivity
    lambda: |-
      if (id(last_modbus_ok_ms) == 0) return false;
      const uint32_t age = millis() - id(last_modbus_ok_ms);
      return age < 20000;

  - platform: template
    name: "Alarm Active"
    id: der_alarm_active
    device_class: problem
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state) != 0;

  - platform: template
    name: "Fault Over Current"
    device_class: problem
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 0) & 1;

  - platform: template
    name: "Fault Over Voltage"
    device_class: problem
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 1) & 1;

  - platform: template
    name: "Under Voltage Fault"
    device_class: problem
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 2) & 1;

  - platform: template
    name: "Fault Over Frequency"
    device_class: problem
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 3) & 1;

  - platform: template
    name: "Under Frequency Fault"
    device_class: problem
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 4) & 1;

  - platform: template
    name: "Fault Voltage Imbalance"
    device_class: problem
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 5) & 1;

  - platform: template
    name: "Fault Current Imbalance"
    device_class: problem
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 6) & 1;

  - platform: template
    name: "Fault Emergency Local"
    device_class: safety
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 7) & 1;

  - platform: template
    name: "Fault Emergency Remote"
    device_class: safety
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 8) & 1;

  - platform: template
    name: "Fault Low Power Input"
    device_class: problem
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 9) & 1;

  - platform: template
    name: "Fault Phase Rotation"
    device_class: problem
    lambda: |-
      return ((uint16_t) id(der_alarm_status).state >> 10) & 1;

text_sensor:
  - platform: template
    name: "Fault Alarm"
    id: der_alarm_list
    icon: mdi:alert-circle-outline
    update_interval: 6s
    lambda: |-
      uint16_t v = (uint16_t) id(der_alarm_status).state;
      if (v == 0) return std::string("OK");

      std::string out;
      auto add = [&](const char* s) { if (!out.empty()) out += ", "; out += s; };

      if (v & (1 << 0))  add("Over Current");
      if (v & (1 << 1))  add("Over Voltage");
      if (v & (1 << 2))  add("Under Voltage");
      if (v & (1 << 3))  add("Over Frequency");
      if (v & (1 << 4))  add("Under Frequency");
      if (v & (1 << 5))  add("Voltage Imbalance");
      if (v & (1 << 6))  add("Current Imbalance");
      if (v & (1 << 7))  add("Emergency Local");
      if (v & (1 << 8))  add("Emergency Remote");
      if (v & (1 << 9))  add("Low Power Input");
      if (v & (1 << 10)) add("Phase Rotation");

      return out;

# ===============================
# PERIODIC ENFORCEMENT
# ===============================
interval:
  - interval: 10min
    then:
      - if:
          condition:
            switch.is_on: enforce_zero_export
          then:
            - number.set:
                id: max_grid_feed_power
                value: 0
            - switch.turn_off: allow_grid_feed_in

# ===============================
# SWITCHES
# ===============================
switch:
  - platform: modbus_controller
    modbus_controller_id: inv
    id: inverter_ac_output
    name: "Inverter AC Output"
    register_type: holding
    address: 0x9C40
    bitmask: 1
    skip_updates: 200

  - platform: modbus_controller
    modbus_controller_id: inv
    id: inverter_restart_pulse
    name: "Inverter Restart (Internal)"
    entity_category: diagnostic
    register_type: holding
    address: 0x9C41
    bitmask: 1
    skip_updates: 200

  - platform: modbus_controller
    modbus_controller_id: inv
    id: allow_grid_feed_in
    name: "Allow Grid Feed-in"
    entity_category: diagnostic
    register_type: holding
    address: 0xA088
    bitmask: 1
    skip_updates: 30

  - platform: template
    name: "Enforce Zero Export"
    id: enforce_zero_export
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

number:
  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_priority_raw
    name: "Load Priority Raw"
    entity_category: diagnostic
    register_type: holding
    address: 0xA028
    value_type: U_WORD
    min_value: 0
    max_value: 3
    step: 1
    skip_updates: 20

  - platform: modbus_controller
    modbus_controller_id: inv
    id: charging_priority_raw
    name: "Charging Priority Raw"
    entity_category: diagnostic
    register_type: holding
    address: 0xA02E
    value_type: U_WORD
    min_value: 0
    max_value: 3
    step: 1
    skip_updates: 20

  - platform: modbus_controller
    modbus_controller_id: inv
    id: max_grid_feed_power
    name: "Max Grid Feed Power (W)"
    register_type: holding
    address: 0xA089
    value_type: U_WORD
    min_value: 0
    max_value: 15000
    step: 50
    skip_updates: 30

select:
  - platform: template
    name: "Inverter Charging Priority"
    id: inverter_charging_priority
    optimistic: false
    options:
      - "Solar priority"
      - "Grid priority"
      - "Hybrid (PV first)"
      - "PV only"
    lambda: |-
      if (!id(charging_priority_raw).has_state()) return std::string("Solar priority");
      int v = (int) id(charging_priority_raw).state;
      if (v == 0) return std::string("Solar priority");
      if (v == 1) return std::string("Grid priority");
      if (v == 2) return std::string("Hybrid (PV first)");
      if (v == 3) return std::string("PV only");
      return std::string("Solar priority");
    set_action:
      - lambda: |-
          uint16_t v = 0;
          if (x == "Solar priority") v = 0;
          else if (x == "Grid priority") v = 1;
          else if (x == "Hybrid (PV first)") v = 2;
          else if (x == "PV only") v = 3;
          id(chgprio_val) = v;
      - number.set:
          id: charging_priority_raw
          value: !lambda "return (float) id(chgprio_val);"

  - platform: template
    name: "Inverter Load Priority"
    id: inverter_load_priority
    optimistic: false
    options:
      - "Solar priority"
      - "Grid priority"
      - "Battery priority"
      - "Hybrid priority"
    lambda: |-
      if (!id(load_priority_raw).has_state()) return std::string("Battery priority");
      int v = (int) id(load_priority_raw).state;
      if (v == 0) return std::string("Solar priority");
      if (v == 1) return std::string("Grid priority");
      if (v == 2) return std::string("Battery priority");
      if (v == 3) return std::string("Hybrid priority");
      return std::string("Battery priority");
    set_action:
      - lambda: |-
          uint16_t v = 2;
          if (x == "Solar priority") v = 0;
          else if (x == "Grid priority") v = 1;
          else if (x == "Battery priority") v = 2;
          else if (x == "Hybrid priority") v = 3;
          id(loadprio_val) = v;
      - number.set:
          id: load_priority_raw
          value: !lambda "return (float) id(loadprio_val);"
