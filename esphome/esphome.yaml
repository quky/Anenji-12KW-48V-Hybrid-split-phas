esphome:
  name: esphome-web-f34b08
  friendly_name: anenji-inverter
  min_version: 2025.11.0
  name_add_mac_suffix: false
  on_boot:
    priority: -100
    then:
      - delay: 10s
      - if:
          condition:
            binary_sensor.is_on: inverter_modbus_ok
          then:
            - number.set:
                id: max_grid_feed_power
                value: 0
            - switch.turn_off: allow_grid_feed_in


esp32:
  variant: esp32s3
  framework:
    type: esp-idf

logger:
  baud_rate: 0
  level: INFO
  logs:
    modbus_controller: WARN
    modbus: WARN

api:

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

time:
  - platform: homeassistant
    id: ha_time

# ===============================
# RS485 (Waveshare ESP32-S3 DIN)
# TX = GPIO17
# RX = GPIO18
# EN = GPIO21
# ===============================
uart:
  id: uart_rs485
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: 9600
  stop_bits: 1
  parity: NONE
  rx_buffer_size: 256

modbus:
  id: modbus1
  uart_id: uart_rs485
  flow_control_pin: GPIO21
  # more conservative timing to reduce CRC errors
  send_wait_time: 500ms

modbus_controller:
  - id: inv
    modbus_id: modbus1
    address: 0x01
    update_interval: 6s
    command_throttle: 750ms
    setup_priority: -10

# ===============================
# GLOBALS (Modbus OK tracking + select helpers)
# ===============================
globals:
  - id: last_modbus_ok_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: chgprio_val
    type: uint16_t
    restore_value: no
    initial_value: "0"

  - id: loadprio_val
    type: uint16_t
    restore_value: no
    initial_value: "0"

# ===============================
# BUTTONS
# ===============================
button:
  - platform: template
    name: "Restart Inverter"
    on_press:
      - switch.turn_on: inverter_restart_pulse
      - delay: 500ms
      - switch.turn_off: inverter_restart_pulse

# ===============================
# SENSORS
# ===============================
sensor:
  # -------- BATTERY (V/A/SOC) --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: batt_v
    name: "Battery Voltage"
    address: 0x7530
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
      # sanity clamp: 40V..70V typical for 48V pack
      - clamp:
          min_value: 40.0
          max_value: 70.0
      - lambda: |-
          // mark "modbus ok" when we see sane data
          id(last_modbus_ok_ms) = millis();
          return x;

  - platform: modbus_controller
    modbus_controller_id: inv
    id: batt_a
    name: "Battery Current"
    address: 0x7531
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
      # reject absurd CRC-glitch currents
      - lambda: |-
          if (isnan(x)) return x;
          if (x < -300.0f || x > 300.0f) return NAN;
          return x;

  - platform: modbus_controller
    modbus_controller_id: inv
    id: batt_soc
    name: "Battery SOC"
    address: 0x7532
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    accuracy_decimals: 0
    filters:
      - lambda: |-
          if (isnan(x)) return x;
          // CRC glitches often show 65000+, force unknown instead
          if (x < 0.0f || x > 100.0f) return NAN;
          id(last_modbus_ok_ms) = millis();
          return x;

  # V*A Power (raw)
  - platform: template
    id: batt_power_va_w
    name: "Battery Power (V*A)"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(batt_v).state) || isnan(id(batt_a).state)) return NAN;
      return id(batt_v).state * id(batt_a).state;

  # Signed battery power (your sign convention)
  - platform: template
    id: battery_power_signed
    name: "Battery Power (Signed)"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(batt_power_va_w).state)) return NAN;
      float p = -id(batt_power_va_w).state;
      if (fabsf(p) < 80.0f) return 0.0f;
      // reject insane spikes caused by CRC glitches
      if (p < -25000.0f || p > 25000.0f) return NAN;
      return p;

  - platform: template
    id: battery_charge_power
    name: "Battery Charge Power"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(battery_power_signed).state)) return NAN;
      float p = id(battery_power_signed).state;
      return (p > 0) ? p : 0;

  - platform: template
    id: battery_discharge_power
    name: "Battery Discharge Power"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(battery_power_signed).state)) return NAN;
      float p = id(battery_power_signed).state;
      return (p < 0) ? (-p) : 0;

  - platform: total_daily_energy
    name: "Battery Charge Energy Today"
    power_id: battery_charge_power
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  - platform: total_daily_energy
    name: "Battery Discharge Energy Today"
    power_id: battery_discharge_power
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  # Read range 0x753B..0x7540 (6 registers) once, then use byte offsets per value.
  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv1_voltage
    name: "PV1 Voltage"
    address: 0x753B
    register_type: holding
    value_type: U_WORD
    register_count: 6          # span the whole PV block in one command
    offset: 0                  # bytes from 0x753B
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv1_current
    name: "PV1 Current"
    address: 0x753B
    register_type: holding
    value_type: U_WORD
    offset: 2                  # 0x753C
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv1_power
    name: "PV1 Power"
    address: 0x753B
    register_type: holding
    value_type: U_WORD
    offset: 4                  # 0x753D
    unit_of_measurement: "W"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv2_voltage
    name: "PV2 Voltage"
    address: 0x753B
    register_type: holding
    value_type: U_WORD
    offset: 6                  # 0x753E
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
      - lambda: |-
          if (isnan(x)) return x;
          if (x < 0.0f || x > 700.0f) return NAN;
          return x;

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv2_current
    name: "PV2 Current"
    address: 0x753B
    register_type: holding
    value_type: S_WORD
    offset: 8                  # 0x753F
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv2_power
    name: "PV2 Power"
    address: 0x753B
    register_type: holding
    value_type: U_WORD
    offset: 10                 # 0x7540
    unit_of_measurement: "W"


  # -------- OUTPUT / LOAD --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_v_l1
    name: "Output Voltage L1"
    address: 0x7548
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: out_hz
    name: "Output Frequency"
    address: 0x754A
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_l1
    name: "Load Power L1 (Output)"
    address: 0x754C
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_total_out
    name: "Load Power Total (Output)"
    address: 0x755E
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: template
    id: load_l2
    name: "Load Power L2 (Output)"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: |-
      if (isnan(id(load_total_out).state) || isnan(id(load_l1).state)) return NAN;
      float v = id(load_total_out).state - id(load_l1).state;
      // reject nonsense from partial corruption
      if (v < -20000.0f || v > 20000.0f) return NAN;
      return v;

  - platform: template
    id: load_total_w
    name: "Load Power Total"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: |-
      if (isnan(id(load_total_out).state)) return NAN;
      return id(load_total_out).state;

  - platform: total_daily_energy
    name: "Load Energy Today"
    power_id: load_total_out
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  # -------- GRID (CT Grid-side) --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: grid_l1
    name: "Grid Power L1 (CT Grid-Side)"
    address: 0x7584
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"
    accuracy_decimals: 0
    filters:
      - lambda: |-
          if (isnan(x)) return x;
          if (x < -30000.0f || x > 30000.0f) return NAN;
          id(last_modbus_ok_ms) = millis();
          return x;

  - platform: modbus_controller
    modbus_controller_id: inv
    id: grid_l2
    name: "Grid Power L2 (CT Grid-Side)"
    address: 0x7585
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"
    accuracy_decimals: 0
    filters:
      - lambda: |-
          if (isnan(x)) return x;
          if (x < -30000.0f || x > 30000.0f) return NAN;
          id(last_modbus_ok_ms) = millis();
          return x;

  - platform: template
    id: grid_power_signed
    name: "Grid Power (Signed)"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(grid_l1).state) || isnan(id(grid_l2).state)) return NAN;
      return id(grid_l1).state + id(grid_l2).state;

  - platform: template
    id: grid_import
    name: "Grid Import Power"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      float v = id(grid_power_signed).state;
      if (isnan(v)) return NAN;
      return (v > 0) ? v : 0;

  - platform: template
    id: grid_export
    name: "Grid Export Power"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      float v = id(grid_power_signed).state;
      if (isnan(v)) return NAN;
      return (v < 0) ? (-v) : 0;

  - platform: template
    id: grid_import_filtered
    name: "Grid Import Power (Filtered)"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      float v = id(grid_import).state;
      if (isnan(v)) return NAN;
      return (v < 25.0f) ? 0.0f : v;

  - platform: template
    id: grid_export_filtered
    name: "Grid Export Power (Filtered)"
    update_interval: 5s
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      float v = id(grid_export).state;
      if (isnan(v)) return NAN;
      return (v < 25.0f) ? 0.0f : v;

  - platform: total_daily_energy
    name: "Grid Import Energy Today"
    power_id: grid_import
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  - platform: total_daily_energy
    name: "Grid Export Energy Today"
    power_id: grid_export
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  # -------- FAN (757E Fan Duty, %) --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: fan_duty
    name: "Fan Duty Cycle"
    address: 0x757E
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"


  # -------- TEMPERATURES (0.1°C) 0x7579..0x757C --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: inv_temp_1_c
    address: 0x7579
    register_type: holding
    value_type: S_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: inv_temp_2_c
    address: 0x757A
    register_type: holding
    value_type: S_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: inv_temp_3_c
    address: 0x757B
    register_type: holding
    value_type: S_WORD
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: inv_temp_4_c
    address: 0x757C
    register_type: holding
    value_type: S_WORD
    filters:
      - multiply: 0.1

  # ---- Convert to °F ----
  - platform: template
    id: inverter_temp_1_f
    name: "Inverter Transformer Temperature"
    unit_of_measurement: "°F"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      float c = id(inv_temp_1_c).state;
      if (isnan(c)) return NAN;
      float f = (c * 9.0f / 5.0f) + 32.0f;
      return roundf(f * 10.0f) / 10.0f;

  - platform: template
    id: inverter_temp_2_f
    name: "Inverter AC Temperature"
    unit_of_measurement: "°F"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      float c = id(inv_temp_2_c).state;
      if (isnan(c)) return NAN;
      float f = (c * 9.0f / 5.0f) + 32.0f;
      return roundf(f * 10.0f) / 10.0f;

  - platform: template
    id: inverter_temp_3_f
    name: "Inverter DC Temperature"
    unit_of_measurement: "°F"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      float c = id(inv_temp_3_c).state;
      if (isnan(c)) return NAN;
      float f = (c * 9.0f / 5.0f) + 32.0f;
      return roundf(f * 10.0f) / 10.0f;

  - platform: template
    id: inverter_temp_4_f
    name: "Inverter Temp Point 4"
    unit_of_measurement: "°F"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      float c = id(inv_temp_4_c).state;
      if (isnan(c)) return NAN;
      float f = (c * 9.0f / 5.0f) + 32.0f;
      return roundf(f * 10.0f) / 10.0f;

  - platform: template
    id: inverter_hottest_temp
    name: "Inverter highest Temperature"
    unit_of_measurement: "°F"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      float t1 = id(inverter_temp_1_f).state;
      float t2 = id(inverter_temp_2_f).state;
      float t3 = id(inverter_temp_3_f).state;
      float t4 = id(inverter_temp_4_f).state;

      bool any = false;
      float mx = -9999.0f;
      if (!isnan(t1)) { any = true; if (t1 > mx) mx = t1; }
      if (!isnan(t2)) { any = true; if (t2 > mx) mx = t2; }
      if (!isnan(t3)) { any = true; if (t3 > mx) mx = t3; }
      if (!isnan(t4)) { any = true; if (t4 > mx) mx = t4; }
      if (!any) return NAN;
      return mx;

  - platform: template
    id: inverter_heartbeat
    name: "Inverter Heartbeat"
    update_interval: 10s
    unit_of_measurement: "s"
    accuracy_decimals: 0
    lambda: |-
      return (float)(millis() / 1000);

# ===============================
# BINARY SENSORS
# ===============================
binary_sensor:
  - platform: status
    name: "Anenji Inverter ESP Online"

  - platform: template
    id: inverter_modbus_ok
    name: "Anenji Inverter Modbus OK"
    device_class: connectivity
    lambda: |-
      const uint32_t age = millis() - id(last_modbus_ok_ms);
      return age < 20000;  // 20s freshness window

# ===============================
# PERIODIC ENFORCEMENT
# ===============================
interval:
  - interval: 10min
    then:
      - if:
          condition:
            switch.is_on: enforce_zero_export
          then:
            - number.set:
                id: max_grid_feed_power
                value: 0
            - switch.turn_off: allow_grid_feed_in

# ===============================
# SWITCHES
# ===============================
switch:
  - platform: modbus_controller
    modbus_controller_id: inv
    id: inverter_ac_output
    name: "Inverter AC Output"
    register_type: holding
    address: 0x9C40
    bitmask: 1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: allow_grid_feed_in
    name: "Allow Grid Feed-in"
    entity_category: diagnostic
    register_type: holding
    address: 0xA088
    bitmask: 1

  - platform: template
    name: "Enforce Zero Export"
    id: enforce_zero_export
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

  - platform: modbus_controller
    modbus_controller_id: inv
    id: inverter_restart_pulse
    name: "Inverter Restart (Internal)"
    entity_category: diagnostic
    register_type: holding
    address: 0x9C41
    bitmask: 1

# ===============================
# NUMBERS
# ===============================
number:
  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_priority_raw
    name: "Load Priority Raw"
    entity_category: diagnostic
    register_type: holding
    address: 0xA028
    value_type: U_WORD
    min_value: 0
    max_value: 3
    step: 1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: charging_priority_raw
    name: "Charging Priority Raw"
    entity_category: diagnostic
    register_type: holding
    address: 0xA02E
    value_type: U_WORD
    min_value: 0
    max_value: 3
    step: 1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: max_grid_feed_power
    name: "Max Grid Feed Power (W)"
    register_type: holding
    address: 0xA089
    value_type: U_WORD
    min_value: 0
    max_value: 15000
    step: 50

# ===============================
# SELECTS (Dropdowns)
# ===============================
select:
  - platform: template
    name: "Inverter Charging Priority"
    optimistic: true
    options:
      - "Solar priority"
      - "Grid priority"
      - "Hybrid (PV first)"
      - "PV only"
    set_action:
      - lambda: |-
          uint16_t v = 0;
          if (x == "Solar priority") v = 0;
          else if (x == "Grid priority") v = 1;
          else if (x == "Hybrid (PV first)") v = 2;
          else if (x == "PV only") v = 3;
          id(chgprio_val) = v;
      - number.set:
          id: charging_priority_raw
          value: !lambda "return (float) id(chgprio_val);"

  - platform: template
    name: "Inverter Load Priority"
    optimistic: true
    options:
      - "Solar priority"
      - "Grid priority"
      - "Battery priority"
      - "Hybrid priority"
    set_action:
      - lambda: |-
          uint16_t v = 0;
          if (x == "Solar priority") v = 0;
          else if (x == "Grid priority") v = 1;
          else if (x == "Battery priority") v = 2;
          else if (x == "Hybrid priority") v = 3;
          id(loadprio_val) = v;
      - number.set:
          id: load_priority_raw
          value: !lambda "return (float) id(loadprio_val);"
