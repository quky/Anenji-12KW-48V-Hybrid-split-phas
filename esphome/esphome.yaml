esphome:
  name: esphome-web-f34b08
  friendly_name: anenji-inverter
  min_version: 2025.11.0
  name_add_mac_suffix: false
  on_boot:
    priority: -100
    then:
      - delay: 10s
      - number.set:
          id: max_grid_feed_power
          value: 0
      - switch.turn_off: allow_grid_feed_in

esp32:
  variant: esp32s3
  framework:
    type: esp-idf

logger:
  baud_rate: 0

api:

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

time:
  - platform: homeassistant
    id: ha_time

uart:
  id: uart_rs485
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: 9600
  stop_bits: 1
  parity: NONE
  rx_buffer_size: 256

modbus:
  id: modbus1
  uart_id: uart_rs485
  flow_control_pin: GPIO21
  send_wait_time: 200ms

modbus_controller:
  - id: inv
    modbus_id: modbus1
    address: 0x01
    update_interval: 2s
    command_throttle: 200ms
    setup_priority: -10

button:
  - platform: template
    name: "Restart Inverter"
    on_press:
      - switch.turn_on: inverter_restart_pulse
      - delay: 500ms
      - switch.turn_off: inverter_restart_pulse

sensor:
  - platform: modbus_controller
    modbus_controller_id: inv
    id: batt_v
    name: "Battery Voltage"
    address: 0x7530
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters: [{ multiply: 0.1 }]

  - platform: modbus_controller
    modbus_controller_id: inv
    id: batt_a
    name: "Battery Current"
    address: 0x7531
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters: [{ multiply: 0.1 }]

  - platform: modbus_controller
    modbus_controller_id: inv
    name: "Battery SOC"
    address: 0x7532
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"

  - platform: template
    id: batt_power_w
    name: "Battery Power (Approx)"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(batt_v).state) || isnan(id(batt_a).state)) return NAN;
      return id(batt_v).state * id(batt_a).state;

  - platform: template
    id: batt_charge_w
    name: "Battery Charge Power"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(batt_power_w).state)) return NAN;
      float p = id(batt_power_w).state;
      return (p > 0) ? p : 0;

  - platform: template
    id: batt_discharge_w
    name: "Battery Discharge Power"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(batt_power_w).state)) return NAN;
      float p = id(batt_power_w).state;
      return (p < 0) ? (-p) : 0;

  - platform: total_daily_energy
    name: "Battery Charge Energy Today"
    power_id: batt_charge_w
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  - platform: total_daily_energy
    name: "Battery Discharge Energy Today"
    power_id: batt_discharge_w
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  # -------- PV --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv1
    name: "PV1 Power"
    address: 0x753D
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "W"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: pv2
    name: "PV2 Power"
    address: 0x7540
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "W"

  - platform: template
    id: pv_total
    name: "PV Total Power"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(pv1).state) || isnan(id(pv2).state)) return NAN;
      return id(pv1).state + id(pv2).state;

  - platform: total_daily_energy
    id: pv_energy_today
    name: "PV Energy Today"
    power_id: pv_total
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  # -------- OUTPUT / LOAD --------
  - platform: modbus_controller
    modbus_controller_id: inv
    name: "Output Voltage L1"
    address: 0x7548
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters: [{ multiply: 0.1 }]

  - platform: modbus_controller
    modbus_controller_id: inv
    name: "Output Frequency"
    address: 0x754A
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    accuracy_decimals: 2
    filters: [{ multiply: 0.01 }]

  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_l1
    name: "Load Power L1 (Output)"
    address: 0x754C
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_total_out
    name: "Load Power Total (Output)"
    address: 0x755E
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: template
    id: load_l2
    name: "Load Power L2 (Output)"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(load_total_out).state) || isnan(id(load_l1).state)) return NAN;
      return id(load_total_out).state - id(load_l1).state;

  - platform: template
    id: load_total_w
    name: "Load Power Total"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(load_total_out).state)) return NAN;
      return id(load_total_out).state;

  - platform: total_daily_energy
    name: "Load Energy Today"
    power_id: load_total_out
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  # -------- GRID (CT) --------
  - platform: modbus_controller
    modbus_controller_id: inv
    id: grid_l1
    name: "Grid Power L1 (CT Grid-Side)"
    address: 0x7584
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: modbus_controller
    modbus_controller_id: inv
    id: grid_l2
    name: "Grid Power L2 (CT Grid-Side)"
    address: 0x7585
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "W"

  - platform: template
    id: grid_total
    name: "Grid Power Total (Signed)"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(grid_l1).state) || isnan(id(grid_l2).state)) return NAN;
      return id(grid_l1).state + id(grid_l2).state;

  # Define these BEFORE anything that references them
  - platform: template
    id: grid_import
    name: "Grid Import Power"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(grid_total).state)) return NAN;
      float v = id(grid_total).state;
      return (v > 0) ? v : 0;

  - platform: template
    id: grid_export
    name: "Grid Export Power"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(grid_total).state)) return NAN;
      float v = id(grid_total).state;
      return (v < 0) ? (-v) : 0;

  - platform: total_daily_energy
    name: "Grid Import Energy Today"
    power_id: grid_import
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  - platform: total_daily_energy
    name: "Grid Export Energy Today"
    power_id: grid_export
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    method: trapezoid
    filters:
      - multiply: 0.001

  - platform: template
    name: "Self Consumption Power"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(pv_total).state) || isnan(id(grid_export).state)) return NAN;
      float self_use = id(pv_total).state - id(grid_export).state;
      if (self_use < 0) self_use = 0;
      return self_use;

switch:
  - platform: modbus_controller
    modbus_controller_id: inv
    name: "Inverter AC Output"
    register_type: holding
    address: 0x9C40
    bitmask: 1

  - platform: modbus_controller
    modbus_controller_id: inv
    id: allow_grid_feed_in
    name: "Allow Grid Feed-in"
    entity_category: diagnostic
    register_type: holding
    address: 0xA088
    bitmask: 1

  - platform: template
    name: "Enforce Zero Export"
    id: enforce_zero_export
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

  - platform: modbus_controller
    modbus_controller_id: inv
    id: inverter_restart_pulse
    name: "Inverter Restart (Internal)"
    entity_category: diagnostic
    register_type: holding
    address: 0x9C41
    bitmask: 1


number:
  - platform: modbus_controller
    modbus_controller_id: inv
    id: charging_priority_raw
    name: "Charging Priority Raw"
    entity_category: diagnostic
    register_type: holding
    address: 0xA02E
    value_type: U_WORD
    min_value: 0
    max_value: 3
    step: 1


  - platform: modbus_controller
    modbus_controller_id: inv
    id: max_grid_feed_power
    name: "Max Grid Feed Power (W)"
    register_type: holding
    address: 0xA089
    value_type: U_WORD
    min_value: 0
    max_value: 15000
    step: 50

  # ✅ ADD THIS
  - platform: modbus_controller
    modbus_controller_id: inv
    id: load_priority_raw
    name: "Load Priority Raw"
    entity_category: diagnostic
    register_type: holding
    address: 0xA028
    value_type: U_WORD
    min_value: 0
    max_value: 3
    step: 1

select:
  - platform: template
    name: "Inverter Charging Priority"
    optimistic: true
    options:
      - "Solar priority"
      - "Grid priority"
      - "Hybrid (PV first)"
      - "PV only"
    set_action:
      - lambda: |-
          uint16_t v = 0;
          if (x == "Solar priority") v = 0;
          else if (x == "Grid priority") v = 1;
          else if (x == "Hybrid (PV first)") v = 2;
          else if (x == "PV only") v = 3;
          id(chgprio_val) = v;
      - number.set:
          id: charging_priority_raw
          value: !lambda "return (float) id(chgprio_val);"

  # ✅ ADD THIS (Load / Output Priority)
  - platform: template
    name: "Inverter Load Priority"
    optimistic: true
    options:
      - "Solar priority"
      - "Grid priority"
      - "Battery priority"
      - "Hybrid priority"
    set_action:
      - lambda: |-
          uint16_t v = 0;
          if (x == "Solar priority") v = 0;
          else if (x == "Grid priority") v = 1;
          else if (x == "Battery priority") v = 2;
          else if (x == "Hybrid priority") v = 3;
          id(loadprio_val) = v;
      - number.set:
          id: load_priority_raw
          value: !lambda "return (float) id(loadprio_val);"
globals:
  - id: chgprio_val
    type: uint16_t
    restore_value: no
    initial_value: "0"

  # ✅ ADD THIS
  - id: loadprio_val
    type: uint16_t
    restore_value: no
    initial_value: "0"
    
interval:
  # Re-enforce every 10 minutes (very light touch)
  - interval: 10min
    then:
      - if:
          condition:
            switch.is_on: enforce_zero_export
          then:
            - number.set:
                id: max_grid_feed_power
                value: 0
